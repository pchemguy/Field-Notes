# **VSCode Agent Workflow for Documentation Reconstruction and Architecture Extraction**

*TrakEM2 Fork — Stage 1 Documentation Construction*

This document defines how VSCode AI agents (OpenAI Codex Agent, Gemini Code Assist Agent) interact with the repository to produce consolidated documentation for the TrakEM2 Java codebase.
It describes:
* The multi-phase workflow
* Agent responsibilities
* Human responsibilities
* File-generation plan
* Prompt templates
* Iterative refinement cycles

This workflow is designed so that Stage 2 (Python translation and interactive exploration) becomes straightforward and reproducible.

---

# **1. Overall Workflow Summary**

The workflow is divided into five major phases:

1. **Workspace Discovery & Symbol Mapping**
   Extract packages, classes, key entry points, data structures.
2. **Architecture Reconstruction**
   Organize system into subsystems, high-level responsibilities, execution flows, and key algorithms.
3. **Documentation Synthesis**
   Generate canonical documentation files under `docs/`.
4. **Cross-Linking with External Documentation**
   Integrate material from the wiki, ImageJ site, legacy manual, and Fiji Javadoc (human provides excerpts).
5. **Refinement Cycles**
   Re-run analysis, strengthen cross-references, clarify ambiguities, validate missing pieces.

---

# **2. Roles and Responsibilities**

## **Human**

* Dispatches tasks to the VSCode agent.
* Reviews and approves generated files.
* Performs Git commits.
* Requests refinements.

## **AI Agent**

* Analyzes Java code.
* Creates or updates documentation files.
* Extracts architectural insights.
* Identifies unclear or incomplete areas.
* Suggests follow-up tasks.

---

# **3. Directory Structure for Documentation**

The agent will produce the following documents:

```
docs/
    DESIGN.md
    ARCHITECTURE.md
    COMPONENTS.md
    ALGORITHMS.md
    API_MAPPING.md
    AGENTS.md
    DOCUMENTATION_PLAN.md
    LEGACY_REFERENCES.md
    VSCODE_AGENT_WORKFLOW.md  <-- this file
    _analysis/
        symbol_map.md
        dependency_graph.md
        execution_flows.md
    _generated/
        scratch_notes.md
```

* `_analysis/` contains intermediate artifacts generated by the agent.
* `_generated/` contains temporary material that will eventually be distilled into the main docs.

---

# **4. Multi-Phase Workflow**

## **Phase 0 — Optional: Initial Scan**

Human may ask the agent:

> “Scan this workspace and summarize directory structure and Java packages.”

The agent produces a structured tree with notes.

---

## **Phase 1 — Symbol Extraction**

Agent tasks:
* Enumerate all Java packages.
* List classes, interfaces, enums.
* Extract class responsibilities (based on names, comments, context).
* Identify major data models.
* Produce output into:

```
docs/_analysis/symbol_map.md
```

Deliverables include:
* Package → classes map
* Class → description draft
* Identification of probable subsystems
* Notes on complexity hotspots

---

## **Phase 2 — Architecture Reconstruction**

Agent tasks:
* Identify principal subsystems (UI, data structures, operations, rendering, IO, etc.).
* Extract execution flows for main entry points.
* Identify algorithm clusters.
* Describe how components interact.
* Produce:

```
docs/ARCHITECTURE.md
docs/COMPONENTS.md
docs/ALGORITHMS.md
```

---

## **Phase 3 — Canonical Documentation Synthesis**

Agent generates:

### **DESIGN.md**

* Purpose and design philosophy
* Historical notes
* High-level responsibilities

### **API_MAPPING.md**

* Mapping Java → conceptual → Python
* Notes on algorithmic translation considerations

### **AGENTS.md**

* Instructions for future LLM agents exploring the repo
* Prompt templates
* File-navigation guidance

### **DOCUMENTATION_PLAN.md**

* What remains missing
* Planned future additions

---

## **Phase 4 — Cross-Linking External Documentation**

Agent tasks:
- Reads `docs/EXTERNAL_SOURCES.md` and fetches external documentation based on information within `docs/EXTERNAL_SOURCES.md`. All external content must come from this manifest unless the user explicitly provides additional sources.
- Performs additional tasks related to external documentation specified in `docs/EXTERNAL_SOURCES.md` 
* Integrate references into `LEGACY_REFERENCES.md`
* Back-link architecture and algorithm descriptions
* Resolve conceptual gaps

---

## **Phase 5 — Refinement Cycles**

Agent:
* Re-runs symbol extraction to detect missing pieces
* Highlights documentation inconsistencies
* Suggests reorganization or expansion
* Updates files incrementally

Human:
* Reviews changes and approves further tasks

---

# **5. VSCode Agent Prompt Templates**

These templates may be re-used across repositories.

---

## **5.1. Workspace Discovery**

```
Scan the workspace. Generate a summary of directories and Java packages,
and produce a structured overview of subsystem candidates.
Write results to docs/_analysis/symbol_map.md.
```

---

## **5.2. Class & Component Analysis**

```
For directory <path>, list all Java classes, summarize responsibilities,
and describe relationships. Output to docs/_analysis/symbol_map.md.
```

---

## **5.3. Execution Flow Extraction**

```
Analyze class <ClassName>. Extract execution flow in structured pseudocode.
Document input/output behavior and cross-references.
Write results to docs/_analysis/execution_flows.md.
```

---

## **5.4. Architecture Reconstruction**

```
Using symbol_map.md and execution_flows.md,
generate docs/ARCHITECTURE.md with subsystem definitions,
data flow, and component roles.
```

---

## **5.5. Algorithm Inventory**

```
Extract all major algorithms implemented in the codebase and
summarize them with inputs, outputs, invariants, and side effects.
Write results to docs/ALGORITHMS.md.
```

---

## **5.6. Draft Python Mapping**

```
Generate conceptual Java → Python mapping for major components.
Do not translate code; describe translation strategy and constraints.
Write to docs/API_MAPPING.md.
```

---

## **5.7. Agent Navigation Guide**

```
Create docs/AGENTS.md explaining how LLM agents should navigate this
repository, interpret documentation, and answer user architectural questions.
```

---

# **6. Refinement Procedure**

Each refinement cycle follows this pattern:
1. Human requests a specific action (“Refine X”).
2. Agent performs targeted analysis or documentation update.
3. Agent outputs changes to files.
4. Human reviews file diffs.
5. Human either:
    * Requests further refinements, or
    * Commits changes.

---

# **7. Quality Expectations**

Documentation must be:
* Accurate
* Internally consistent
* Organized
* Explicit about relationships
* Useful to both LLM agents and human developers
* Suitable for downstream Python re-implementations


