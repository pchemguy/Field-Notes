# Prompt

My particular interest here is on someone trying to get into / gain early experience in a particular area with little/limited to no experience specific experience. In such a context, the wise approach is to start with non-novel relatively tractable (training/educational/pedagogical) problems, that is known practical problems where existence of potential practical solutions can be expected from quick high-level analysis of relevant technical fields. Potential overarching goal could be developing of an alternative solution, basic/simplified reverse engineering / reimplementation of an existing solution or focusing on niche problems that are expected to be solvable, but did not attract much developer attention due to limited potential applications.

For example, the task of analysis of lab photos containing samples over millimeter graph paper is common in certain branches of experimental biology. There are a number of existing approaches to automating it, yet there are still niche setups, such as smartphone-taken pictures of animal organs, with no obvious off-the-shelf tool/solution available. The primary relevant technical field - computer vision. From high-level understanding of CV state, it can be deduced that under certain moderate constrains this task should be solvable: the very high-level analysis could identify two key subtasks - grid detection and object segmentation, both of which are established tasks in both ML and non-ML CV.

When starting a new problem-oriented project (as opposed to learning or just for fun), I guess the first question to address (or at least to posit) is about the target problem to be solved, initial understanding of any constraints and the unmet need.

The second stage as, I see it, is to analyze potential solution approaches/workflows. The objective is to split the task into tractable more or less well-defined LOOSELY COUPLED sub-tasks with well-defined potential/prospective input/output artifacts, akin to pluggable blocks. Ideally, each sub-task should have a limited set of dependencies, could be quickly prototyped and later developed into a production block. The sub-tasks should be as independent as possible defining specific objectives in relatively abstract terms (such as preprocessing, grid detection, grid analysis, geometry distortion analysis and correction, segmentation, error analysis, etc.) so that different alternative approaches could be quickly tested for different subtasks with none to minimum consequences to implementation details of other subtasks.

For training problems, SOTA AI will likely posses detailed context to devise task-splitting strategies. But it is of course important to draft/consider potential splitting without any AI assistance both for educational/training purposes, as well as to reduce chances of letting AI having limited initial context lock you in a random particular approach. Essentially, the second stage should be considered as highly exploratory and it is, in fact, important to brainstorm alternatives early to avoid early unjustified fixation on potentially suboptimal techniques/tactics. Early ideas / understanding can then be provided to AI as extended context, which should be instructed to critically evaluate them, yielding collaborative solutions as part of iterative/interactive improvement process.

The second component of the second stage is, perhaps, analysis of relative complexity/importance of various subtasks. The objective is to identify the steps and devise strategies to isolate such steps and quickly prototype them to verify feasibility of specific tactics and gauge initial performance/efficacy/robustness (whatever is most relevant; e.g., performance in terms of the calculation time often is almost completely irrelevant at early stages). For example, it might be readily obvious that robust preprocessing of input images is essential for optimal downstream processing. However, it is also clear that image preprocessing is a supplementary step and early focusing on automating/prototyping it is most likely unwarranted. Instead, try to come up with a robust preprocessing workflow manually using a suitable off-the-shelf tool, produce a preprocessed image(s), and use it/them in while prototyping more problem-specific steps. Preprocessing can always be automated, if necessary later, when there are promising initial results from testing early prototypes of the key steps. Even for the key steps see, if there are any readily available tools implementing specific CV algorithms that can/should be integrated. Even if the tool cannot be readily integrated in the production product and the algos would need to be reimplemented, early testing with available solutions will provide quick feedback as to weather it is even worth trying to implement a particular algo/tactic/workflow/approach. While it is important to beware of potential AI locks when requesting specific solutions to early with insufficient context, for integral multistep tasks, it is important to understand that active involvement of a SOTA AI with global memory performs project-specific model alignment, facilitating later development process.

Once there is an initial rough understanding of potential technical solution with basic tested loose bunch of code snippets/modules, it is probably important to jump the focus to the very end. Ask what kind end-product we are trying to produce. For example, a standalone gui or cli tool that could be used on Windows/Linux/cross-platform, with no dev dependencies (say, boxed, no need for installed Python). Should it be able to process image sets, say, directories. What kind of output is to be generated (intermediate images are probably important for understanding the progress, assessing correctness, identifying issues; tabular/textual output to be generated)? When using Python as the development platform, this stage is particularly important, as it is important to have a clear understanding how the coded tool could be packaged into a standalone product and what constrains needs to be followed from the very beginning of development of an integrated prototype.
